"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.errorFactory = errorFactory;
exports.getCompileFn = getCompileFn;
exports.getModernWebpackImporter = getModernWebpackImporter;
exports.getSassImplementation = getSassImplementation;
exports.getSassOptions = getSassOptions;
exports.getWebpackImporter = getWebpackImporter;
exports.getWebpackResolver = getWebpackResolver;
exports.normalizeSourceMap = normalizeSourceMap;
var _url = _interopRequireDefault(require("url"));
var _path = _interopRequireDefault(require("path"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function getDefaultSassImplementation() {
  let sassImplPkg = "sass";
  try {
    require.resolve("sass");
  } catch (ignoreError) {
    try {
      require.resolve("node-sass");
      sassImplPkg = "node-sass";
    } catch (_ignoreError) {
      try {
        require.resolve("sass-embedded");
        sassImplPkg = "sass-embedded";
      } catch (__ignoreError) {
        sassImplPkg = "sass";
      }
    }
  }

  // eslint-disable-next-line import/no-dynamic-require, global-require
  return require(sassImplPkg);
}

/**
 * This function is not Webpack-specific and can be used by tools wishing to mimic `sass-loader`'s behaviour, so its signature should not be changed.
 */
function getSassImplementation(loaderContext, implementation) {
  let resolvedImplementation = implementation;
  if (!resolvedImplementation) {
    resolvedImplementation = getDefaultSassImplementation();
  }
  if (typeof resolvedImplementation === "string") {
    // eslint-disable-next-line import/no-dynamic-require, global-require
    resolvedImplementation = require(resolvedImplementation);
  }
  const {
    info
  } = resolvedImplementation;
  if (!info) {
    throw new Error("Unknown Sass implementation.");
  }
  const infoParts = info.split("\t");
  if (infoParts.length < 2) {
    throw new Error(`Unknown Sass implementation "${info}".`);
  }
  const [implementationName] = infoParts;
  if (implementationName === "dart-sass") {
    // eslint-disable-next-line consistent-return
    return resolvedImplementation;
  } else if (implementationName === "node-sass") {
    // eslint-disable-next-line consistent-return
    return resolvedImplementation;
  } else if (implementationName === "sass-embedded") {
    // eslint-disable-next-line consistent-return
    return resolvedImplementation;
  }
  throw new Error(`Unknown Sass implementation "${implementationName}".`);
}

/**
 * @param {any} loaderContext
 * @returns {boolean}
 */
function isProductionLikeMode(loaderContext) {
  return loaderContext.mode === "production" || !loaderContext.mode;
}
function proxyCustomImporters(importers, loaderContext) {
  return [].concat(importers).map(importer => function proxyImporter(...args) {
    const self = {
      ...this,
      webpackLoaderContext: loaderContext
    };
    return importer.apply(self, args);
  });
}

/**
 * Derives the sass options from the loader context and normalizes its values with sane defaults.
 *
 * @param {object} loaderContext
 * @param {object} loaderOptions
 * @param {string} content
 * @param {object} implementation
 * @param {boolean} useSourceMap
 * @returns {Object}
 */
async function getSassOptions(loaderContext, loaderOptions, content, implementation, useSourceMap) {
  const options = loaderOptions.sassOptions ? typeof loaderOptions.sassOptions === "function" ? loaderOptions.sassOptions(loaderContext) || {} : loaderOptions.sassOptions : {};
  const sassOptions = {
    ...options,
    data: loaderOptions.additionalData ? typeof loaderOptions.additionalData === "function" ? await loaderOptions.additionalData(content, loaderContext) : `${loaderOptions.additionalData}\n${content}` : content
  };
  if (!sassOptions.logger) {
    const needEmitWarning = loaderOptions.warnRuleAsWarning !== false;
    const logger = loaderContext.getLogger("sass-loader");
    const formatSpan = span => `Warning on line ${span.start.line}, column ${span.start.column} of ${span.url || "-"}:${span.start.line}:${span.start.column}:\n`;
    const formatDebugSpan = span => `[debug:${span.start.line}:${span.start.column}] `;
    sassOptions.logger = {
      debug(message, loggerOptions) {
        let builtMessage = "";
        if (loggerOptions.span) {
          builtMessage = formatDebugSpan(loggerOptions.span);
        }
        builtMessage += message;
        logger.debug(builtMessage);
      },
      warn(message, loggerOptions) {
        let builtMessage = "";
        if (loggerOptions.deprecation) {
          builtMessage += "Deprecation ";
        }
        if (loggerOptions.span) {
          builtMessage += formatSpan(loggerOptions.span);
        }
        builtMessage += message;
        if (loggerOptions.span && loggerOptions.span.context) {
          builtMessage += `\n\n${loggerOptions.span.start.line} | ${loggerOptions.span.context}`;
        }
        if (loggerOptions.stack && loggerOptions.stack !== "null") {
          builtMessage += `\n\n${loggerOptions.stack}`;
        }
        if (needEmitWarning) {
          const warning = new Error(builtMessage);
          warning.name = "SassWarning";
          warning.stack = null;
          loaderContext.emitWarning(warning);
        } else {
          logger.warn(builtMessage);
        }
      }
    };
  }
  const isModernAPI = loaderOptions.api === "modern" || loaderOptions.api === "modern-compiler";
  const {
    resourcePath
  } = loaderContext;
  if (isModernAPI) {
    sassOptions.url = _url.default.pathToFileURL(resourcePath);

    // opt.outputStyle
    if (!sassOptions.style && isProductionLikeMode(loaderContext)) {
      sassOptions.style = "compressed";
    }
    if (useSourceMap) {
      sassOptions.sourceMap = true;
    }

    // If we are compiling sass and indentedSyntax isn't set, automatically set it.
    if (typeof sassOptions.syntax === "undefined") {
      const ext = _path.default.extname(resourcePath);
      if (ext && ext.toLowerCase() === ".scss") {
        sassOptions.syntax = "scss";
      } else if (ext && ext.toLowerCase() === ".sass") {
        sassOptions.syntax = "indented";
      } else if (ext && ext.toLowerCase() === ".css") {
        sassOptions.syntax = "css";
      }
    }
    sassOptions.loadPaths = [].concat(
    // We use `loadPaths` in context for resolver, so it should be always absolute
    (sassOptions.loadPaths ? sassOptions.loadPaths.slice() : []).map(includePath => _path.default.isAbsolute(includePath) ? includePath : _path.default.join(process.cwd(), includePath))).concat(process.env.SASS_PATH ? process.env.SASS_PATH.split(process.platform === "win32" ? ";" : ":") : []);
    sassOptions.importers = sassOptions.importers ? Array.isArray(sassOptions.importers) ? sassOptions.importers.slice() : [sassOptions.importers] : [];
  } else {
    sassOptions.file = resourcePath;

    // opt.outputStyle
    if (!sassOptions.outputStyle && isProductionLikeMode(loaderContext)) {
      sassOptions.outputStyle = "compressed";
    }
    if (useSourceMap) {
      // Deliberately overriding the sourceMap option here.
      // node-sass won't produce source maps if the data option is used and options.sourceMap is not a string.
      // In case it is a string, options.sourceMap should be a path where the source map is written.
      // But since we're using the data option, the source map will not actually be written, but
      // all paths in sourceMap.sources will be relative to that path.
      // Pretty complicated... :(
      sassOptions.sourceMap = true;
      sassOptions.outFile = _path.default.join(loaderContext.rootContext, "style.css.map");
      sassOptions.sourceMapContents = true;
      sassOptions.omitSourceMapUrl = true;
      sassOptions.sourceMapEmbed = false;
    }
    const ext = _path.default.extname(resourcePath);

    // If we are compiling sass and indentedSyntax isn't set, automatically set it.
    if (ext && ext.toLowerCase() === ".sass" && typeof sassOptions.indentedSyntax === "undefined") {
      sassOptions.indentedSyntax = true;
    } else {
      sassOptions.indentedSyntax = Boolean(sassOptions.indentedSyntax);
    }

 