{"version":3,"file":"index.js","sources":["../src/util.ts","../src/index.ts"],"sourcesContent":["import { types as t, type NodePath, type Visitor } from \"@babel/core\";\nimport { requeueComputedKeyAndDecorators } from \"@babel/helper-environment-visitor\";\n\nfunction isNameOrLength(key: t.Node): boolean {\n  if (t.isIdentifier(key)) {\n    return key.name === \"name\" || key.name === \"length\";\n  }\n  if (t.isStringLiteral(key)) {\n    return key.value === \"name\" || key.value === \"length\";\n  }\n  return false;\n}\n\nfunction isStaticFieldWithValue(\n  node: t.Node,\n): node is t.ClassProperty | t.ClassPrivateProperty {\n  return (\n    (t.isClassProperty(node) || t.isClassPrivateProperty(node)) &&\n    node.static &&\n    !!node.value\n  );\n}\n\nconst hasReferenceVisitor: Visitor<{ name: string; ref: () => void }> = {\n  ReferencedIdentifier(path, state) {\n    if (path.node.name === state.name) {\n      state.ref();\n      path.stop();\n    }\n  },\n  Scope(path, { name }) {\n    if (path.scope.hasOwnBinding(name)) {\n      path.skip();\n    }\n  },\n};\n\nfunction isReferenceOrThis(node: t.Node, name?: string) {\n  return t.isThisExpression(node) || (name && t.isIdentifier(node, { name }));\n}\n\nconst hasReferenceOrThisVisitor: Visitor<{ name?: string; ref: () => void }> = {\n  \"ThisExpression|ReferencedIdentifier\"(path, state) {\n    if (isReferenceOrThis(path.node, state.name)) {\n      state.ref();\n      path.stop();\n    }\n  },\n  FunctionParent(path, state) {\n    if (path.isArrowFunctionExpression()) return;\n    if (state.name && !path.scope.hasOwnBinding(state.name)) {\n      path.traverse(hasReferenceVisitor, state);\n    }\n    path.skip();\n    if (path.isMethod()) {\n      requeueComputedKeyAndDecorators(path);\n    }\n  },\n};\n\ntype ClassElementWithComputedKeySupport = Extract<\n  t.ClassBody[\"body\"][number],\n  { computed?: boolean }\n>;\n\n/**\n * This function returns an array containing the indexes of class elements\n * that might be affected by https://crbug.com/v8/12421 bug.\n *\n * This bug affects public static class fields that have the same name as an\n * existing non-writable property with the same name. This usually happens when\n * the static field is named 'length' or 'name', since it clashes with the\n * predefined fn.length and fn.name properties. We must also compile static\n * fields with computed key, because they might end up being named 'length' or\n * 'name'.\n *\n * However, this bug can potentially affect public static fields with any name.\n * Consider this example:\n *\n *     class A {\n *       static {\n *         Object.defineProperty(A, \"readonly\", {\n *           value: 1,\n *           writable: false,\n *           configurable: true\n *         })\n *       }\n *\n *       static readonly = 2;\n *     }\n *\n * When initializing the 'static readonly' field, the class already has a\n * non-writable property named 'readonly' and thus V8 9.7 incorrectly throws.\n *\n * To avoid unconditionally compiling every public static field, we track how\n * the class is referenced during definition & static evaluation: any side\n * effect after a reference to the class can potentially define a non-writable\n * conficting property, so subsequent public static fields must be compiled.\n * The class could be referenced using the class name in computed keys, which\n * run before static fields, or using either the class name or 'this' in static\n * fields (both public and private) and static blocks.\n *\n * We don't need to check if computed keys referencing the class have any side\n * effect, because during the computed keys evaluation the internal class\n * binding is in TDZ. However, the first side effect in a static field/block\n * could have access to a function defined in a computed key that modifies the\n * class.\n *\n * This logic is already quite complex, so we assume that static blocks always\n * have side effects and reference the class (the reason to use them is to\n * perform additional initialization logic on the class anyway), so that we do\n * not have to check their contents.\n */\nexport function getPotentiallyBuggyFieldsIndexes(path: NodePath<t.Class>) {\n  const buggyPublicStaticFieldsIndexes: number[] = [];\n\n  let classReferenced = false;\n  const className = path.node.id?.name;\n\n  const hasReferenceState = {\n    name: className,\n    ref: () => (classReferenced = true),\n  };\n\n  if (className) {\n    for (const el of path.get(\"body.body\")) {\n      if ((el.node as ClassElementWithComputedKeySupport).computed) {\n        // Since .traverse skips the top-level node, it doesn't detect\n        // a reference happening immediately:\n        //     class A { [A]() {} }\n        // However, it's a TDZ error so it's ok not to consider this case.\n        (el as NodePath<ClassElementWithComputedKeySupport>)\n          .get(\"key\")\n          .traverse(hasReferenceVisitor, hasReferenceState);\n\n        if (classReferenced) break;\n      }\n    }\n  }\n\n  let nextPotentiallyBuggy = false;\n\n  const { body } = path.node.body;\n  for (let i = 0; i < body.length; i++) {\n    const node = body[i];\n\n    if (!nextPotentiallyBuggy) {\n      if (t.isStaticBlock(node)) {\n        classReferenced = true;\n        nextPotentiallyBuggy = true;\n      } else if (isStaticFieldWithValue(node)) {\n        if (!classReferenced) {\n          if (isReferenceOrThis(node.value, className)) {\n            classReferenced = true;\n          } else {\n            (\n              path.get(`body.body.${i}.value`) as NodePath<t.Expression>\n            ).traverse(hasReferenceOrThisVisitor, hasReferenceState);\n          }\n        }\n\n        if (classReferenced) {\n          nextPotentiallyBuggy = !path.scope.isPure(node.value);\n        }\n      }\n    }\n\n    if (\n      t.isClassProperty(node, { static: true }) &&\n      (nextPotentiallyBuggy || node.computed || isNameOrLength(node.key))\n    ) {\n      buggyPublicStaticFieldsIndexes.push(i);\n    }\n  }\n\n  return buggyPublicStaticFieldsIndexes;\n}\n\nexport function getNameOrLengthStaticFieldsIndexes(path: NodePath<t