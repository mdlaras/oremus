{"version":3,"names":["_helperPluginUtils","require","_path","_helperModuleTransforms","_core","buildPrerequisiteAssignment","template","buildWrapper","_default","exports","default","declare","api","options","_api$assumption","_api$assumption2","assertVersion","globals","exactGlobals","allowTopLevelThis","strict","strictMode","noInterop","importInterop","constantReexports","assumption","loose","enumerableModuleMeta","buildBrowserInit","browserGlobals","filename","moduleName","moduleNameOrBasename","value","basename","extname","globalToAssign","t","memberExpression","identifier","toIdentifier","initAssignments","globalName","members","split","slice","reduce","accum","curr","push","GLOBAL_REFERENCE","cloneNode","expressionStatement","assignmentExpression","buildBrowserArg","source","globalRef","requireName","name","visitor","Program","exit","path","isModule","getModuleName","file","opts","moduleNameLiteral","stringLiteral","meta","headers","rewriteModuleStatementsAndPrepareHeader","amdArgs","commonjsArgs","browserArgs","importNames","hasExports","exportName","metadata","callExpression","isSideEffectImport","interop","wrapInterop","header","loc","buildNamespaceInitStatements","ensureStatementsHoisted","unshiftContainer","body","directives","node","umdWrapper","pushContainer","MODULE_NAME","AMD_ARGUMENTS","arrayExpression","COMMONJS_ARGUMENTS","BROWSER_ARGUMENTS","IMPORT_NAMES","GLOBAL_TO_ASSIGN","umdFactory","get"],"sources":["../src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport { basename, extname } from \"path\";\nimport {\n  isModule,\n  rewriteModuleStatementsAndPrepareHeader,\n  type RewriteModuleStatementsAndPrepareHeaderOptions,\n  hasExports,\n  isSideEffectImport,\n  buildNamespaceInitStatements,\n  ensureStatementsHoisted,\n  wrapInterop,\n  getModuleName,\n} from \"@babel/helper-module-transforms\";\nimport type { PluginOptions } from \"@babel/helper-module-transforms\";\nimport { types as t, template, type NodePath } from \"@babel/core\";\n\nconst buildPrerequisiteAssignment = template(`\n  GLOBAL_REFERENCE = GLOBAL_REFERENCE || {}\n`);\n// Note: we avoid comparing typeof results with \"object\" or \"symbol\" otherwise\n// they will be processed by `transform-typeof-symbol`, which in return could\n// cause typeof helper used before declaration\nconst buildWrapper = template(`\n  (function (global, factory) {\n    if (typeof define === \"function\" && define.amd) {\n      define(MODULE_NAME, AMD_ARGUMENTS, factory);\n    } else if (typeof exports !== \"undefined\") {\n      factory(COMMONJS_ARGUMENTS);\n    } else {\n      var mod = { exports: {} };\n      factory(BROWSER_ARGUMENTS);\n\n      GLOBAL_TO_ASSIGN;\n    }\n  })(\n    typeof globalThis !== \"undefined\" ? globalThis\n      : typeof self !== \"undefined\" ? self\n      : this,\n    function(IMPORT_NAMES) {\n  })\n`);\n\nexport interface Options extends PluginOptions {\n  allowTopLevelThis?: boolean;\n  exactGlobals?: boolean;\n  globals?: Record<string, string>;\n  importInterop?: RewriteModuleStatementsAndPrepareHeaderOptions[\"importInterop\"];\n  loose?: boolean;\n  noInterop?: boolean;\n  strict?: boolean;\n  strictMode?: boolean;\n}\n\nexport default declare((api, options: Options) => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  const {\n    globals,\n    exactGlobals,\n    allowTopLevelThis,\n    strict,\n    strictMode,\n    noInterop,\n    importInterop,\n  } = options;\n\n  const constantReexports =\n    api.assumption(\"constantReexports\") ?? options.loose;\n  const enumerableModuleMeta =\n    api.assumption(\"enumerableModuleMeta\") ?? options.loose;\n\n  /**\n   * Build the assignment statements that initialize the UMD global.\n   */\n  function buildBrowserInit(\n    browserGlobals: Record<string, string>,\n    exactGlobals: boolean,\n    filename: string,\n    moduleName: t.StringLiteral | void,\n  ) {\n    const moduleNameOrBasename = moduleName\n      ? moduleName.value\n      : basename(filename, extname(filename));\n    let globalToAssign = t.memberExpression(\n      t.identifier(\"global\"),\n      t.identifier(t.toIdentifier(moduleNameOrBasename)),\n    );\n    let initAssignments = [];\n\n    if (exactGlobals) {\n      const globalName = browserGlobals[moduleNameOrBasename];\n\n      if (globalName) {\n        initAssignments = [];\n\n        const members = globalName.split(\".\");\n        globalToAssign = members.slice(1).reduce(\n          (accum, curr) => {\n            initAssignments.push(\n              buildPrerequisiteAssignment({\n                GLOBAL_REFERENCE: t.cloneNode(accum),\n              }),\n            );\n            return t.memberExpression(accum, t.identifier(curr));\n          },\n          t.memberExpression(t.identifier(\"global\"), t.identifier(members[0])),\n        );\n      }\n    }\n\n    initAssignments.push(\n      t.expressionStatement(\n        t.assignmentExpression(\n          \"=\",\n          globalToAssign,\n          t.memberExpression(t.identifier(\"mod\"), t.identifier(\"exports\")),\n        ),\n      ),\n    );\n\n    return initAssig