"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.exec = exec;
exports.findPackageJSONDir = findPackageJSONDir;
exports.getPostcssImplementation = getPostcssImplementation;
exports.getPostcssOptions = getPostcssOptions;
exports.loadConfig = loadConfig;
exports.normalizeSourceMap = normalizeSourceMap;
exports.normalizeSourceMapAfterPostcss = normalizeSourceMapAfterPostcss;
exports.reportError = reportError;
exports.warningFactory = warningFactory;
var _path = _interopRequireDefault(require("path"));
var _url = _interopRequireDefault(require("url"));
var _module = _interopRequireDefault(require("module"));
var _cosmiconfig = require("cosmiconfig");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const parentModule = module;
const stat = (inputFileSystem, filePath) => new Promise((resolve, reject) => {
  inputFileSystem.stat(filePath, (err, stats) => {
    if (err) {
      reject(err);
    }
    resolve(stats);
  });
});
function exec(code, loaderContext) {
  const {
    resource,
    context
  } = loaderContext;
  const module = new _module.default(resource, parentModule);

  // eslint-disable-next-line no-underscore-dangle
  module.paths = _module.default._nodeModulePaths(context);
  module.filename = resource;

  // eslint-disable-next-line no-underscore-dangle
  module._compile(code, resource);
  return module.exports;
}
let tsLoader;
async function loadConfig(loaderContext, config, postcssOptions) {
  const searchPath = typeof config === "string" ? _path.default.resolve(config) : _path.default.dirname(loaderContext.resourcePath);
  let stats;
  try {
    stats = await stat(loaderContext.fs, searchPath);
  } catch (errorIgnore) {
    throw new Error(`No PostCSS config found in: ${searchPath}`);
  }
  const moduleName = "postcss";
  const searchPlaces = [
  // Prefer popular format
  "package.json", `${moduleName}.config.js`, `${moduleName}.config.mjs`, `${moduleName}.config.cjs`, `${moduleName}.config.ts`, `${moduleName}.config.mts`, `${moduleName}.config.cts`, `.${moduleName}rc`, `.${moduleName}rc.json`, `.${moduleName}rc.js`, `.${moduleName}rc.mjs`, `.${moduleName}rc.cjs`, `.${moduleName}rc.ts`, `.${moduleName}rc.mts`, `.${moduleName}rc.cts`, `.${moduleName}rc.yaml`, `.${moduleName}rc.yml`, `.config/${moduleName}rc`, `.config/${moduleName}rc.json`, `.config/${moduleName}rc.yaml`, `.config/${moduleName}rc.yml`, `.config/${moduleName}rc.js`, `.config/${moduleName}rc.mjs`, `.config/${moduleName}rc.cjs`, `.config/${moduleName}rc.ts`, `.config/${moduleName}rc.mts`, `.config/${moduleName}rc.cts`];
  const loaders = {
    ".js": async (...args) => {
      let result;
      try {
        result = _cosmiconfig.defaultLoadersSync[".js"](...args);
      } catch (error) {
        let importESM;
        try {
          // eslint-disable-next-line no-new-func
          importESM = new Function("id", "return import(id);");
        } catch (e) {
          importESM = null;
        }
        if (error.code === "ERR_REQUIRE_ESM" && _url.default.pathToFileURL && importESM) {
          const urlForConfig = _url.default.pathToFileURL(args[0]);
          result = await importESM(urlForConfig);
        } else {
          throw error;
        }
      }
      if (result.default) {
        return result.default;
      }
      return result;
    },
    ".cjs": _cosmiconfig.defaultLoadersSync[".cjs"],
    ".mjs": async (...args) => {
      let result;
      let importESM;
      try {
        // eslint-disable-next-line no-new-func
        importESM = new Function("id", "return import(id);");
      } catch (e) {
        importESM = null;
      }
      if (_url.default.pathToFileURL && importESM) {
        const urlForConfig = _url.default.pathToFileURL(args[0]);
        result = await importESM(urlForConfig);
      } else {
        throw new Error("ESM is not supported");
      }
      if (result.default) {
        return result.default;
      }
      return result;
    }
  };
  if (!tsLoader) {
    const opts = {
      interopDefault: true
    };
    // eslint-disable-next-line global-require, import/no-extraneous-dependencies
    const jiti = require("jiti")(__filename, opts);
    tsLoader = filepath => jiti(filepath);
  }
  loaders[".cts"] = tsLoader;
  loaders[".mts"] = tsLoader;
  loaders[".ts"] = tsLoader;
  const explorer = (0, _cosmiconfig.cosmiconfig)(moduleName, {
    searchStrategy: "global",
    searchPlaces,
    loaders
  });
  let result;
  try {
    if (stats.isFile()) {
      result = await explorer.load(searchPath);
    } else {
      result = await explorer.search(searchPath);
    }
  } catch (error) {
    throw error;
  }
  if (!result) {
    return {};
  }
  loaderContext.addBuildDependency(result.filepath);
  loaderContext.addDependency(result.filepath);
  if (result.isEmpty) {
    return result;
  }
  if (typeof result.config === "function") {
    const api = {
      mode: loaderContext.mode,
      file: loaderContext.resourcePath,
      // For complex use
      webpackLoaderContext: loaderContext,
      // Partial compatibility with `postcss-cli`
      env: loaderContext.mode,
      options: postcssOptions || {}
    };
    return {
      ...result,
      config: result.config(api)
    };
  }
  return result;
}
function loadPlugin(plugin, options, file) {
  try {
    // eslint-disable-next-line global-require, import/no-dynamic-require
    let loadedPlugin = require(plugin);
    if (loadedPlugin.default) {
      loadedPlugin = loadedPlugin.default;
    }
    if (!options || Object.keys(options).length === 0) {
      return loadedPlugin;
    }
    return loadedPlugin(options);
  } catch (error) {
    throw new Error(`Loading PostCSS "${plugin}" plugin failed: ${error.message}\n\n(@${file})`);
  }
}
function pluginFactory() {
  const listOfPlugins = new Map();
  return plugins => {
    if (typeof plugins === "undefined") {
      return listOfPlugins;
    }
    if (Array.isArray(plugins)) {
      for (const plugin of plugins) {
        if (Array.isArray(plugin)) {
          const [name, options] = plugin;
          listOfPlugins.set(name, options);
        } else if (plugin && typeof plugin === "function") {
          listOfPlugins.set(plugin);
        } else if (plugin && Object.keys(plugin).length === 1 && (typeof plugin[Object.keys(plugin)[0]] === "object" || typeof plugin[Object.keys(plugin)[0]] === "boolean") && plugin[Object.keys(plugin)[0]] !== null) {
          const [name] = Object.keys(plugin);
          const options = plugin[name];
          if (options === false) {
            listOfPlugins.delete(name);
          } else {
            listO